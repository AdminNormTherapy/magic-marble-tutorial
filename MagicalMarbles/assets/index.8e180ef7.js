var e=Object.defineProperty,n=Object.defineProperties,r=Object.getOwnPropertyDescriptors,t=Object.getOwnPropertySymbols,a=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable,i=(n,r,t)=>r in n?e(n,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[r]=t,c=(e,n)=>{for(var r in n||(n={}))a.call(n,r)&&i(e,r,n[r]);if(t)for(var r of t(n))o.call(n,r)&&i(e,r,n[r]);return e};import{r as l,u as s,R as p,a as m,C as v,O as u,E as f,b as d,S as g,B as h,c as y,d as S,N as b,e as x,f as O,M as w,g as E,h as D}from"./vendor.7acd971c.js";const M=[[0,100,50],[60,100,50],[150,100,50],[240,70,60],[0,0,80]];function P(){const[e,n]=l.exports.useState(0),{hsl:r}=s({hsl:M[e%M.length],config:{tension:50}}),t=r.to(((e,n,r)=>`radial-gradient(hsl(${e}, ${.7*n}%, ${r}%), hsl(${e},${.4*n}%, ${.2*r}%))`));return p.createElement(m.div,{style:{background:t,width:"100%",height:"100%"}},p.createElement(v,{camera:{position:[0,0,2]}},p.createElement(l.exports.Suspense,{fallback:null},p.createElement(u,{autoRotate:!0,enableRotate:!1,enablePan:!1,enableZoom:!1}),p.createElement(B,{step:e,setStep:n}),p.createElement(f,{preset:"warehouse"}))))}function B({step:e,setStep:n}){const[r,t]=l.exports.useState(!1),[a,o]=l.exports.useState(!1),{scale:i}=s({scale:a&&r?.95:1,config:{friction:15,tension:300}});return p.createElement("group",null,p.createElement(d.group,{scale:i,onPointerEnter:()=>t(!0),onPointerOut:()=>t(!1),onClick:()=>n(e+1)},p.createElement(g,{args:[1,64,32]},p.createElement(j,{step:e,roughness:.1}))),p.createElement(h,{args:[100,100,100],onPointerDown:()=>o(!0),onPointerUp:()=>o(!1)},p.createElement("meshBasicMaterial",{side:y,visible:!1})))}function j(e){var i=e,{step:m}=i,v=((e,n)=>{var r={};for(var i in e)a.call(e,i)&&n.indexOf(i)<0&&(r[i]=e[i]);if(null!=e&&t)for(var i of t(e))n.indexOf(i)<0&&o.call(e,i)&&(r[i]=e[i]);return r})(i,["step"]);const u=S("noise.jpg"),f=S("displacement.jpg");u.minFilter=f.minFilter=b,u.wrapS=u.wrapT=x,f.wrapS=f.wrapT=x;const[d]=l.exports.useState((()=>({time:{value:0},colorA:{value:new O(0,0,0)},colorB:{value:new O(1,0,0)},worldToLocal:{value:new w},noiseMap:{value:u},displacementMap:{value:f},iterations:{value:64},maxDepth:{value:.75},smoothing:{value:.2},refraction:{value:.7},displacementStrength:{value:.04}})));d.noiseMap.value=u,d.displacementMap.value=f;const{timeOffset:g}=s({hsl:M[m%M.length],timeOffset:.2*m,config:{tension:50},onChange:({value:{hsl:e}})=>{const[n,r,t]=e;d.colorB.value.setHSL(n/360,r/100,t/100)}});E((({clock:e})=>{d.time.value=g.get()+.05*e.elapsedTime}));const h=e=>{((e,n)=>{e.uniforms=c(c({},e.uniforms),n)})(e,d),((e,n)=>{e.vertexShader=n+"\n"+e.vertexShader})(e,"\n      uniform mat4 worldToLocal;\n\n      varying vec3 v_pos;\n      varying vec3 v_dir;\n    "),((e,n)=>{e.vertexShader=e.vertexShader.replace(/void main\(\) {/,(e=>e+n))})(e,"\n      vec3 cameraPositionLocal = (worldToLocal * vec4(cameraPosition, 1.0)).xyz;\n      v_dir = position - cameraPositionLocal; // Local vec from camera to vert\n      v_pos = position;\n    "),((e,n)=>{e.fragmentShader=n+"\n"+e.fragmentShader})(e,"\n      uniform float time;\n      uniform vec3 colorA;\n      uniform vec3 colorB;\n      uniform sampler2D noiseMap;\n      uniform sampler2D displacementMap;\n      uniform int iterations;\n      uniform float maxDepth;\n      uniform float smoothing;\n      uniform float refraction;\n      uniform float displacementStrength;\n\n      varying vec3 v_pos;\n      varying vec3 v_dir;\n\n      /**\n       * @param {vec3} p - 3D position\n       * @returns {vec2} UV coordinate on a unit sphere \n       */\n      vec2 uvSphere(vec3 p) {\n        vec3 pn = normalize(p);\n        float u = 0.5 - atan(pn.z, pn.x) / (2. * 3.1415926);\n        float v = 0.5 + asin(pn.y) / 3.1415926;\n        return vec2(u, v);\n      }\n\n      /**\n       * Note: we assume a unit sphere\n       * \n       * @param {vec3} rayOrigin - Point on sphere\n       * @param {vec3} rayDir - Normalized view direction\n       * @returns {vec3} Accumulated RGB color\n       */\n      vec3 marchMarble(vec3 rayOrigin, vec3 rayDir) {\n        float perIteration = 1. / float(iterations);\n        vec3 deltaRay = rayDir * perIteration * maxDepth;\n        float c = 0.;\n\n        // Start at point of intersection\n        vec3 p = rayOrigin;\n\n        for (int i=0; i<iterations; ++i) {\n          vec2 uv = uvSphere(p);\n          vec3 displacementA = texture(displacementMap, uv + vec2(time, 0.)).rgb * 2. - 1.;\n          vec3 displacementB = texture(displacementMap, vec2(uv.x, -uv.y) - vec2(time, 0.)).rgb * 2. - 1.;\n          uv = uvSphere(p + (displacementA + displacementB) * displacementStrength);\n          float noiseVal = texture(noiseMap, uv).r;\n          float height = length(p); // 1 at surface, 0 at core\n          float cutoff = 1. - float(i) * perIteration;\n          float mask = smoothstep(cutoff, cutoff + smoothing, noiseVal);\n          c += mask * perIteration;\n          p += deltaRay;\n        }\n        return mix(colorA, colorB, c);\n      }\n      "),e.fragmentShader=e.fragmentShader.replace(/vec4 diffuseColor.*;/,"\n        vec3 rayOrigin = normalize(v_pos);\n        vec3 norm = -rayOrigin;\n        \n        vec3 rayDir = normalize(v_dir);\n        rayDir = mix(rayDir, norm, refraction);\n        rayDir = normalize(rayDir);\n\n        vec3 rgb = marchMarble(rayOrigin, rayDir);\n        vec4 diffuseColor = vec4( rgb, opacity);\n      ")};return p.createElement("meshStandardMaterial",(y=c({},v),n(y,r({onBeforeCompile:h,onUpdate:e=>e.needsUpdate=!0,customProgramCacheKey:()=>h.toString()}))));var y}D.render(p.createElement(p.StrictMode,null,p.createElement(P,null)),document.getElementById("root"));
